{"ast":null,"code":"'use strict';\n\nvar nextTick = require('./lib/next-tick');\n\nmodule.exports = Promise;\n\nfunction Promise(fn) {\n  if (!(this instanceof Promise)) return new Promise(fn);\n  if (typeof fn !== 'function') throw new TypeError('not a function');\n  var state = null;\n  var delegating = false;\n  var value = null;\n  var deferreds = [];\n  var self = this;\n\n  this.then = function (onFulfilled, onRejected) {\n    return new Promise(function (resolve, reject) {\n      handle(new Handler(onFulfilled, onRejected, resolve, reject));\n    });\n  };\n\n  function handle(deferred) {\n    if (state === null) {\n      deferreds.push(deferred);\n      return;\n    }\n\n    nextTick(function () {\n      var cb = state ? deferred.onFulfilled : deferred.onRejected;\n\n      if (cb === null) {\n        (state ? deferred.resolve : deferred.reject)(value);\n        return;\n      }\n\n      var ret;\n\n      try {\n        ret = cb(value);\n      } catch (e) {\n        deferred.reject(e);\n        return;\n      }\n\n      deferred.resolve(ret);\n    });\n  }\n\n  function resolve(newValue) {\n    if (delegating) return;\n    resolve_(newValue);\n  }\n\n  function resolve_(newValue) {\n    if (state !== null) return;\n\n    try {\n      //Promise Resolution Procedure: https://github.com/promises-aplus/promises-spec#the-promise-resolution-procedure\n      if (newValue === self) throw new TypeError('A promise cannot be resolved with itself.');\n\n      if (newValue && (typeof newValue === 'object' || typeof newValue === 'function')) {\n        var then = newValue.then;\n\n        if (typeof then === 'function') {\n          delegating = true;\n          then.call(newValue, resolve_, reject_);\n          return;\n        }\n      }\n\n      state = true;\n      value = newValue;\n      finale();\n    } catch (e) {\n      reject_(e);\n    }\n  }\n\n  function reject(newValue) {\n    if (delegating) return;\n    reject_(newValue);\n  }\n\n  function reject_(newValue) {\n    if (state !== null) return;\n    state = false;\n    value = newValue;\n    finale();\n  }\n\n  function finale() {\n    for (var i = 0, len = deferreds.length; i < len; i++) {\n      handle(deferreds[i]);\n    }\n\n    deferreds = null;\n  }\n\n  try {\n    fn(resolve, reject);\n  } catch (e) {\n    reject(e);\n  }\n}\n\nfunction Handler(onFulfilled, onRejected, resolve, reject) {\n  this.onFulfilled = typeof onFulfilled === 'function' ? onFulfilled : null;\n  this.onRejected = typeof onRejected === 'function' ? onRejected : null;\n  this.resolve = resolve;\n  this.reject = reject;\n}","map":null,"metadata":{},"sourceType":"script"}